# Generated by Django 4.2.13 on 2025-12-02 08:27

from django.db import migrations, models
import django.db.models.deletion
import re


def backfill_order_number_counters(apps, schema_editor):
    """
    Backfill OrderNumberCounter for each (tenant, store_location) combination.

    Sets next_value to max(existing order number) + 1 for each location,
    ensuring new orders continue the sequence without gaps or collisions.
    """
    Order = apps.get_model('orders', 'Order')
    OrderNumberCounter = apps.get_model('orders', 'OrderNumberCounter')

    # Find all unique (tenant, store_location) combinations with orders
    location_combos = (
        Order.objects
        .filter(store_location__isnull=False)
        .values('tenant_id', 'store_location_id')
        .distinct()
    )

    prefix = "ORD-"
    counters_to_create = []

    for combo in location_combos:
        tenant_id = combo['tenant_id']
        store_location_id = combo['store_location_id']

        # Find the highest order number for this location
        last_order = (
            Order.objects
            .filter(
                tenant_id=tenant_id,
                store_location_id=store_location_id,
                order_number__startswith=prefix
            )
            .order_by('-order_number')
            .first()
        )

        next_value = 1
        if last_order and last_order.order_number:
            match = re.match(rf"^{re.escape(prefix)}(\d+)$", last_order.order_number)
            if match:
                next_value = int(match.group(1)) + 1

        counters_to_create.append(
            OrderNumberCounter(
                tenant_id=tenant_id,
                store_location_id=store_location_id,
                next_value=next_value
            )
        )

    # Dedupe by (tenant_id, store_location_id) in case of duplicates
    seen = set()
    deduped_counters = []
    for counter in counters_to_create:
        key = (counter.tenant_id, counter.store_location_id)
        if key not in seen:
            seen.add(key)
            deduped_counters.append(counter)

    # Bulk create, ignoring conflicts if counters already exist
    # (e.g., runtime allocator created them before migration ran)
    if deduped_counters:
        OrderNumberCounter.objects.bulk_create(deduped_counters, ignore_conflicts=True)
        print(f"Backfilled {len(deduped_counters)} order number counters")


def reverse_backfill(apps, schema_editor):
    """Reverse migration: delete all counters (table will be dropped anyway)."""
    OrderNumberCounter = apps.get_model('orders', 'OrderNumberCounter')
    OrderNumberCounter.objects.all().delete()


class Migration(migrations.Migration):

    dependencies = [
        ('tenant', '0006_tenant_internal_notes_tenant_ownership_type_and_more'),
        ('settings', '0032_globalsettings_created_at_globalsettings_updated_at_and_more'),
        ('orders', '0032_add_offline_order_tracking'),
    ]

    operations = [
        migrations.CreateModel(
            name='OrderNumberCounter',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('next_value', models.PositiveIntegerField(default=1, help_text='Next order number to allocate')),
                ('created_at', models.DateTimeField(auto_now_add=True)),
                ('updated_at', models.DateTimeField(auto_now=True)),
                ('store_location', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='order_number_counters', to='settings.storelocation')),
                ('tenant', models.ForeignKey(on_delete=django.db.models.deletion.CASCADE, related_name='order_number_counters', to='tenant.tenant')),
            ],
            options={
                'db_table': 'orders_order_number_counter',
                'indexes': [models.Index(fields=['tenant', 'store_location'], name='orders_orde_tenant__2f6c8e_idx')],
            },
        ),
        migrations.AddConstraint(
            model_name='ordernumbercounter',
            constraint=models.UniqueConstraint(fields=('tenant', 'store_location'), name='unique_counter_per_tenant_location'),
        ),
        # Backfill counters from existing orders
        migrations.RunPython(backfill_order_number_counters, reverse_backfill),
    ]
