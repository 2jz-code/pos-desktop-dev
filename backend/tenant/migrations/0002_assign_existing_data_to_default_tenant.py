# Generated by Django 4.2.13 on 2025-10-02 17:35

from django.db import migrations, transaction
from django.conf import settings


def assign_existing_data_to_default_tenant(apps, schema_editor):
    """
    Assign all existing data (where tenant is NULL) to the default tenant.

    This migration is part of the multi-tenancy implementation strategy:
    1. Make all tenant FKs nullable âœ…
    2. Run migrations âœ…
    3. Assign existing data to default tenant â† YOU ARE HERE
    4. Make tenant FKs non-nullable (next migration)
    5. Run final migrations
    """
    Tenant = apps.get_model('tenant', 'Tenant')

    # Get default tenant slug from settings
    default_tenant_slug = getattr(settings, 'DEFAULT_TENANT_SLUG', 'myrestaurant')

    try:
        default_tenant = Tenant.objects.get(slug=default_tenant_slug)
        print(f"\nâœ“ Default tenant already exists: {default_tenant.name}")
    except Tenant.DoesNotExist:
        # Create default tenant if it doesn't exist (for fresh migrations)
        print(f"\nðŸ†• Creating default tenant: {default_tenant_slug}")
        default_tenant = Tenant.objects.create(
            slug=default_tenant_slug,
            name='Development' if default_tenant_slug == 'myrestaurant' else default_tenant_slug.title(),
            business_name='Development Restaurant' if default_tenant_slug == 'myrestaurant' else f'{default_tenant_slug.title()} Restaurant',
            contact_email=f'contact@{default_tenant_slug}.com',
            is_active=True
        )
        print(f"âœ“ Created tenant: {default_tenant.name} (ID: {default_tenant.id})")

    print(f"\nðŸ”„ Assigning existing data to tenant: {default_tenant.name} ({default_tenant.slug})")
    print(f"   Tenant ID: {default_tenant.id}\n")

    # Track statistics
    total_updated = 0
    updates_by_model = {}

    # Define all models that need tenant assignment (23 models across 8 apps)
    models_to_update = [
        # users app (1 model)
        ('users', 'User'),

        # products app (8 models)
        ('products', 'Category'),
        ('products', 'Tax'),
        ('products', 'ProductType'),
        ('products', 'Product'),
        ('products', 'ModifierSet'),
        ('products', 'ModifierOption'),
        ('products', 'ProductSpecificOption'),
        ('products', 'ProductModifierSet'),

        # discounts app (1 model)
        ('discounts', 'Discount'),

        # inventory app (5 models)
        ('inventory', 'Location'),
        ('inventory', 'InventoryStock'),
        ('inventory', 'Recipe'),
        ('inventory', 'RecipeItem'),
        ('inventory', 'StockHistoryEntry'),

        # orders app (4 models)
        ('orders', 'Order'),
        ('orders', 'OrderItem'),
        ('orders', 'OrderDiscount'),
        ('orders', 'OrderItemModifier'),

        # payments app (3 models)
        ('payments', 'Payment'),
        ('payments', 'PaymentTransaction'),
        ('payments', 'GiftCard'),

        # reports app (4 models)
        ('reports', 'ReportCache'),
        ('reports', 'SavedReport'),
        ('reports', 'ReportTemplate'),
        ('reports', 'ReportExecution'),

        # settings app (7 models)
        ('settings', 'GlobalSettings'),
        ('settings', 'PrinterConfiguration'),
        ('settings', 'WebOrderSettings'),
        ('settings', 'StoreLocation'),
        ('settings', 'TerminalLocation'),
        ('settings', 'TerminalRegistration'),
        ('settings', 'StockActionReasonConfig'),

        # business_hours app (6 models)
        ('business_hours', 'BusinessHoursProfile'),
        ('business_hours', 'RegularHours'),
        ('business_hours', 'TimeSlot'),
        ('business_hours', 'SpecialHours'),
        ('business_hours', 'SpecialHoursTimeSlot'),
        ('business_hours', 'Holiday'),
    ]

    # Process each model
    for app_label, model_name in models_to_update:
        try:
            Model = apps.get_model(app_label, model_name)

            # Special handling for User model to deal with duplicate usernames
            if app_label == 'users' and model_name == 'User':
                # Get users without tenant
                users_without_tenant = Model.objects.filter(tenant__isnull=True)

                # Update them one by one to handle constraint violations
                updated_count = 0
                skipped_count = 0

                for user in users_without_tenant:
                    try:
                        # Use savepoint to isolate this update
                        with transaction.atomic():
                            Model.objects.filter(pk=user.pk, tenant__isnull=True).update(tenant=default_tenant)
                            updated_count += 1
                    except Exception as e:
                        # Skip users that would violate constraints (likely duplicates)
                        skipped_count += 1
                        print(f"      âš  Skipped user {user.email} (username: {user.username}): {str(e)[:50]}")

                if updated_count > 0:
                    updates_by_model[f"{app_label}.{model_name}"] = updated_count
                    total_updated += updated_count
                    print(f"   âœ“ {app_label}.{model_name}: {updated_count} records")
                    if skipped_count > 0:
                        print(f"      (skipped {skipped_count} duplicates)")
            else:
                # For all other models, use bulk update (with error handling)
                try:
                    updated_count = Model.objects.filter(tenant__isnull=True).update(tenant=default_tenant)

                    if updated_count > 0:
                        updates_by_model[f"{app_label}.{model_name}"] = updated_count
                        total_updated += updated_count
                        print(f"   âœ“ {app_label}.{model_name}: {updated_count} records")
                except Exception as e:
                    # If bulk update fails (e.g., duplicate constraints), process one by one
                    print(f"   âš  {app_label}.{model_name}: Bulk update failed, trying one-by-one...")

                    records_without_tenant = Model.objects.filter(tenant__isnull=True)
                    updated_count = 0
                    skipped_count = 0

                    for record in records_without_tenant:
                        try:
                            with transaction.atomic():
                                Model.objects.filter(pk=record.pk, tenant__isnull=True).update(tenant=default_tenant)
                                updated_count += 1
                        except Exception:
                            skipped_count += 1

                    if updated_count > 0:
                        updates_by_model[f"{app_label}.{model_name}"] = updated_count
                        total_updated += updated_count
                        print(f"   âœ“ {app_label}.{model_name}: {updated_count} records")
                        if skipped_count > 0:
                            print(f"      (skipped {skipped_count} duplicates)")

        except LookupError:
            # Model doesn't exist yet (might be in a different migration state)
            print(f"   âš  {app_label}.{model_name}: Model not found (skipping)")
            continue

    # Print summary
    print(f"\nâœ… Migration complete!")
    print(f"   Total records updated: {total_updated}")
    print(f"   Models processed: {len(updates_by_model)}/{len(models_to_update)}")

    if total_updated == 0:
        print(f"\n   â„¹ï¸  No records needed updating (all records already have tenant assigned)")


def reverse_migration(apps, schema_editor):
    """
    Reverse the migration by setting tenant to NULL for all records
    that belong to the default tenant.

    WARNING: This will orphan all data! Only use in development.
    """
    Tenant = apps.get_model('tenant', 'Tenant')

    default_tenant_slug = getattr(settings, 'DEFAULT_TENANT_SLUG', 'myrestaurant')

    try:
        default_tenant = Tenant.objects.get(slug=default_tenant_slug)
    except Tenant.DoesNotExist:
        print(f"âš ï¸  Default tenant '{default_tenant_slug}' not found. Nothing to reverse.")
        return

    print(f"\nâš ï¸  REVERSING: Setting tenant to NULL for all records of: {default_tenant.name}")
    print(f"   This will orphan data! Only safe in development.\n")

    total_reversed = 0

    # Same model list as forward migration
    models_to_update = [
        ('users', 'User'),
        ('products', 'Category'),
        ('products', 'Tax'),
        ('products', 'ProductType'),
        ('products', 'Product'),
        ('products', 'ModifierSet'),
        ('products', 'ModifierOption'),
        ('products', 'ProductSpecificOption'),
        ('products', 'ProductModifierSet'),
        ('discounts', 'Discount'),
        ('inventory', 'Location'),
        ('inventory', 'InventoryStock'),
        ('inventory', 'Recipe'),
        ('inventory', 'RecipeItem'),
        ('inventory', 'StockHistoryEntry'),
        ('orders', 'Order'),
        ('orders', 'OrderItem'),
        ('orders', 'OrderDiscount'),
        ('orders', 'OrderItemModifier'),
        ('payments', 'Payment'),
        ('payments', 'PaymentTransaction'),
        ('payments', 'GiftCard'),
        ('reports', 'ReportCache'),
        ('reports', 'SavedReport'),
        ('reports', 'ReportTemplate'),
        ('reports', 'ReportExecution'),
        ('settings', 'GlobalSettings'),
        ('settings', 'PrinterConfiguration'),
        ('settings', 'WebOrderSettings'),
        ('settings', 'StoreLocation'),
        ('settings', 'TerminalLocation'),
        ('settings', 'TerminalRegistration'),
        ('settings', 'StockActionReasonConfig'),
        ('business_hours', 'BusinessHoursProfile'),
        ('business_hours', 'RegularHours'),
        ('business_hours', 'TimeSlot'),
        ('business_hours', 'SpecialHours'),
        ('business_hours', 'SpecialHoursTimeSlot'),
        ('business_hours', 'Holiday'),
    ]

    for app_label, model_name in models_to_update:
        try:
            Model = apps.get_model(app_label, model_name)
            reversed_count = Model.objects.filter(tenant=default_tenant).update(tenant=None)

            if reversed_count > 0:
                total_reversed += reversed_count
                print(f"   âœ“ {app_label}.{model_name}: {reversed_count} records")

        except LookupError:
            continue

    print(f"\nâœ… Reverse complete!")
    print(f"   Total records orphaned: {total_reversed}")


class Migration(migrations.Migration):

    dependencies = [
        ('tenant', '0001_initial'),
        # Depend on migrations that added nullable tenant FK
        # (the non-nullable migrations now depend on 0001, not 0002, avoiding cycles)
        ('users', '0013_remove_user_users_user_role_feee3d_idx_and_more'),
        ('products', '0024_remove_product_product_is_public_idx_and_more'),
        ('discounts', '0005_remove_discount_discounts_d_is_acti_d60cd2_idx_and_more'),
        ('inventory', '0011_remove_inventorystock_inventory_product_location_idx_and_more'),
        ('orders', '0023_remove_order_unique_guest_pending_order_and_more'),
        ('payments', '0014_remove_giftcard_payments_gi_code_4a7e40_idx_and_more'),
        ('reports', '0004_remove_reportcache_reports_rep_report__ad8f34_idx_and_more'),
        ('settings', '0016_remove_stockactionreasonconfig_settings_st_is_acti_9dc4a5_idx_and_more'),
    ]

    operations = [
        migrations.RunPython(
            assign_existing_data_to_default_tenant,
            reverse_code=reverse_migration,
        ),
    ]
